
//------------------------------------------------------------------------------
// <auto-generated>
//     This file was automatically generated by Unity.Entities.Editor.BurstInteropCodeGenerator
//     Any changes you make here will be overwritten
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     To update this file, use the "DOTS -> Regenerate Burst Interop" menu option.
//
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Burst;
using Unity.Collections;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Entities.Serialization
{
     unsafe partial struct SerializeUtilityInterop
    {

#if !UNITY_IOS

        [BurstDiscard]
        private static void CheckDelegate(ref bool useDelegate)
        {
            //@TODO: This should use BurstCompiler.IsEnabled once that is available as an efficient API.
            useDelegate = true;
        }

        private static bool UseDelegate()
        {
            bool result = false;
            CheckDelegate(ref result);
            return result;
        }

        static class Managed
        {
            public static bool _initialized = false;

            public delegate void _dlg_AllocateConsecutiveEntitiesForLoading(IntPtr store, int entityCount);
            public static _dlg_AllocateConsecutiveEntitiesForLoading _bfp_AllocateConsecutiveEntitiesForLoading;
            public delegate int _dlg_AllocAndQueueReadChunkCommands(long readOffset, int totalChunkCount, IntPtr megaChunkInfo, IntPtr readCommands);
            public static _dlg_AllocAndQueueReadChunkCommands _bfp_AllocAndQueueReadChunkCommands;
            public delegate void _dlg_AddExistingChunk(IntPtr chunk, IntPtr sharedComponentIndices, IntPtr enabledBitsValuesForChunk, IntPtr perComponentDisabledBitCount);
            public static _dlg_AddExistingChunk _bfp_AddExistingChunk;
            public delegate void _dlg_ImportChunks(IntPtr status, ref Unity.Entities.Serialization.BurstableMemoryBinaryReader bufferReader, IntPtr archetypes, IntPtr sharedComponentArray, int numSharedComponents, IntPtr sharedComponentRemap, IntPtr blobAssetRefChunks, IntPtr componentEnabledBits, IntPtr enabledBitsHierarchicalData, IntPtr ecs, IntPtr chunksWithMetaChunkEntities);
            public static _dlg_ImportChunks _bfp_ImportChunks;
        }


#endif

        [NotBurstCompatible]
        internal static void Initialize()
        {
#if !UNITY_IOS
            if (Managed._initialized)
                return;
            Managed._initialized = true;
            Managed._bfp_AllocateConsecutiveEntitiesForLoading = BurstCompiler.CompileFunctionPointer<Managed._dlg_AllocateConsecutiveEntitiesForLoading>(_mono_to_burst_AllocateConsecutiveEntitiesForLoading).Invoke;
            Managed._bfp_AllocAndQueueReadChunkCommands = BurstCompiler.CompileFunctionPointer<Managed._dlg_AllocAndQueueReadChunkCommands>(_mono_to_burst_AllocAndQueueReadChunkCommands).Invoke;
            Managed._bfp_AddExistingChunk = BurstCompiler.CompileFunctionPointer<Managed._dlg_AddExistingChunk>(_mono_to_burst_AddExistingChunk).Invoke;
            Managed._bfp_ImportChunks = BurstCompiler.CompileFunctionPointer<Managed._dlg_ImportChunks>(_mono_to_burst_ImportChunks).Invoke;

#endif
        }

        internal  static void AllocateConsecutiveEntitiesForLoading (EntityComponentStore* store, int entityCount)
        {
#if !UNITY_IOS
            if (UseDelegate())
            {
                _forward_mono_AllocateConsecutiveEntitiesForLoading(store, entityCount);
                return;
            }
#endif

            _AllocateConsecutiveEntitiesForLoading(store, entityCount);
        }

#if !UNITY_IOS
        [BurstCompile]
        [MonoPInvokeCallback(typeof(Managed._dlg_AllocateConsecutiveEntitiesForLoading))]
        private static void _mono_to_burst_AllocateConsecutiveEntitiesForLoading(IntPtr store, int entityCount)
        {
            _AllocateConsecutiveEntitiesForLoading((EntityComponentStore*)store, entityCount);
        }

        [BurstDiscard]
        private static void _forward_mono_AllocateConsecutiveEntitiesForLoading(EntityComponentStore* store, int entityCount)
        {
            Managed._bfp_AllocateConsecutiveEntitiesForLoading((IntPtr) store, entityCount);
        }
#endif

        internal  static int AllocAndQueueReadChunkCommands (long readOffset, int totalChunkCount, UnsafeList<Unity.Entities.Serialization.SerializeUtility.MegaChunkInfo>* megaChunkInfo, UnsafeList<Unity.IO.LowLevel.Unsafe.ReadCommand>* readCommands)
        {
#if !UNITY_IOS
            if (UseDelegate())
            {
                var _retval = default(int);
                _forward_mono_AllocAndQueueReadChunkCommands(ref _retval, readOffset, totalChunkCount, megaChunkInfo, readCommands);
                return _retval;
            }
#endif

            return _AllocAndQueueReadChunkCommands(readOffset, totalChunkCount, megaChunkInfo, readCommands);
        }

#if !UNITY_IOS
        [BurstCompile]
        [MonoPInvokeCallback(typeof(Managed._dlg_AllocAndQueueReadChunkCommands))]
        private static int _mono_to_burst_AllocAndQueueReadChunkCommands(long readOffset, int totalChunkCount, IntPtr megaChunkInfo, IntPtr readCommands)
        {
            return _AllocAndQueueReadChunkCommands(readOffset, totalChunkCount, (UnsafeList<Unity.Entities.Serialization.SerializeUtility.MegaChunkInfo>*)megaChunkInfo, (UnsafeList<Unity.IO.LowLevel.Unsafe.ReadCommand>*)readCommands);
        }

        [BurstDiscard]
        private static void _forward_mono_AllocAndQueueReadChunkCommands(ref int _retval, long readOffset, int totalChunkCount, UnsafeList<Unity.Entities.Serialization.SerializeUtility.MegaChunkInfo>* megaChunkInfo, UnsafeList<Unity.IO.LowLevel.Unsafe.ReadCommand>* readCommands)
        {
            _retval = Managed._bfp_AllocAndQueueReadChunkCommands(readOffset, totalChunkCount, (IntPtr) megaChunkInfo, (IntPtr) readCommands);
        }
#endif

        internal  static void AddExistingChunk (Chunk* chunk, int* sharedComponentIndices, byte* enabledBitsValuesForChunk, int* perComponentDisabledBitCount)
        {
#if !UNITY_IOS
            if (UseDelegate())
            {
                _forward_mono_AddExistingChunk(chunk, sharedComponentIndices, enabledBitsValuesForChunk, perComponentDisabledBitCount);
                return;
            }
#endif

            _AddExistingChunk(chunk, sharedComponentIndices, enabledBitsValuesForChunk, perComponentDisabledBitCount);
        }

#if !UNITY_IOS
        [BurstCompile]
        [MonoPInvokeCallback(typeof(Managed._dlg_AddExistingChunk))]
        private static void _mono_to_burst_AddExistingChunk(IntPtr chunk, IntPtr sharedComponentIndices, IntPtr enabledBitsValuesForChunk, IntPtr perComponentDisabledBitCount)
        {
            _AddExistingChunk((Chunk*)chunk, (int*)sharedComponentIndices, (byte*)enabledBitsValuesForChunk, (int*)perComponentDisabledBitCount);
        }

        [BurstDiscard]
        private static void _forward_mono_AddExistingChunk(Chunk* chunk, int* sharedComponentIndices, byte* enabledBitsValuesForChunk, int* perComponentDisabledBitCount)
        {
            Managed._bfp_AddExistingChunk((IntPtr) chunk, (IntPtr) sharedComponentIndices, (IntPtr) enabledBitsValuesForChunk, (IntPtr) perComponentDisabledBitCount);
        }
#endif

        internal  static void ImportChunks (Unity.Entities.Serialization.SerializeUtility.WorldDeserializationStatus* status, ref Unity.Entities.Serialization.BurstableMemoryBinaryReader bufferReader, UnsafeList<EntityArchetype>* archetypes, int* sharedComponentArray, int numSharedComponents, int* sharedComponentRemap, UnsafeList<ArchetypeChunk>* blobAssetRefChunks, byte* componentEnabledBits, int* enabledBitsHierarchicalData, EntityComponentStore* ecs, UnsafeList<ArchetypeChunk>* chunksWithMetaChunkEntities)
        {
#if !UNITY_IOS
            if (UseDelegate())
            {
                _forward_mono_ImportChunks(status, ref bufferReader, archetypes, sharedComponentArray, numSharedComponents, sharedComponentRemap, blobAssetRefChunks, componentEnabledBits, enabledBitsHierarchicalData, ecs, chunksWithMetaChunkEntities);
                return;
            }
#endif

            _ImportChunks(status, ref bufferReader, archetypes, sharedComponentArray, numSharedComponents, sharedComponentRemap, blobAssetRefChunks, componentEnabledBits, enabledBitsHierarchicalData, ecs, chunksWithMetaChunkEntities);
        }

#if !UNITY_IOS
        [BurstCompile]
        [MonoPInvokeCallback(typeof(Managed._dlg_ImportChunks))]
        private static void _mono_to_burst_ImportChunks(IntPtr status, ref Unity.Entities.Serialization.BurstableMemoryBinaryReader bufferReader, IntPtr archetypes, IntPtr sharedComponentArray, int numSharedComponents, IntPtr sharedComponentRemap, IntPtr blobAssetRefChunks, IntPtr componentEnabledBits, IntPtr enabledBitsHierarchicalData, IntPtr ecs, IntPtr chunksWithMetaChunkEntities)
        {
            _ImportChunks((Unity.Entities.Serialization.SerializeUtility.WorldDeserializationStatus*)status, ref bufferReader, (UnsafeList<EntityArchetype>*)archetypes, (int*)sharedComponentArray, numSharedComponents, (int*)sharedComponentRemap, (UnsafeList<ArchetypeChunk>*)blobAssetRefChunks, (byte*)componentEnabledBits, (int*)enabledBitsHierarchicalData, (EntityComponentStore*)ecs, (UnsafeList<ArchetypeChunk>*)chunksWithMetaChunkEntities);
        }

        [BurstDiscard]
        private static void _forward_mono_ImportChunks(Unity.Entities.Serialization.SerializeUtility.WorldDeserializationStatus* status, ref Unity.Entities.Serialization.BurstableMemoryBinaryReader bufferReader, UnsafeList<EntityArchetype>* archetypes, int* sharedComponentArray, int numSharedComponents, int* sharedComponentRemap, UnsafeList<ArchetypeChunk>* blobAssetRefChunks, byte* componentEnabledBits, int* enabledBitsHierarchicalData, EntityComponentStore* ecs, UnsafeList<ArchetypeChunk>* chunksWithMetaChunkEntities)
        {
            Managed._bfp_ImportChunks((IntPtr) status, ref bufferReader, (IntPtr) archetypes, (IntPtr) sharedComponentArray, numSharedComponents, (IntPtr) sharedComponentRemap, (IntPtr) blobAssetRefChunks, (IntPtr) componentEnabledBits, (IntPtr) enabledBitsHierarchicalData, (IntPtr) ecs, (IntPtr) chunksWithMetaChunkEntities);
        }
#endif




    }
}
